package org.iitkgp.ndl.core;

import java.util.LinkedList;
import java.util.Queue;

import org.apache.commons.lang3.StringUtils;

/**
 * Prefix tree map based on {@link String} key and unknown type value.
 * To add value the value needs to be splitted based on which prefix-tree node built
 * @param T the value type
 * @see NDLFieldTokenSplitter
 * @see NDLFieldTokenSplittingLoader
 * @see NDLMapKeyProcessor
 * @author Debasis
 */
public class NDLMap<T> {
	// prefix tree based NDL-map<String, T>
	// root node
	NDLMapEntryNode<T> rootNode = new NDLMapEntryNode<T>("__HOME__", false);
	NDLMapKeyProcessor<T> keyProcessor = null; // this required to iterate and post-process on found an entry
	
	/**
	 * Sets key-processor, it needs when iterates each entry in prefix-tree
	 * @param keyProcessor key-processor to post-process on found an entry
	 * @see #iterate()
	 */
	public void setKeyProcessor(NDLMapKeyProcessor<T> keyProcessor) {
		this.keyProcessor = keyProcessor;
	}
	
	/**
	 * Adds an entry in form of tokens
	 * @param tokens tokens, generated by splitting logic
	 * @param data value associated with key/entry
	 * @see NDLFieldTokenSplitter
	 * @see NDLFieldTokenSplittingLoader
	 */
	public void add(String tokens[], T data) {
		// adds tokens
		NDLMapEntryNode<T> node = rootNode;
		for(String token : tokens) {
			if(StringUtils.isNotBlank(token)) {
				// valid
				node = node.addKey(token);
			}
		}
		// add data
		node.setData(data);
	}
	
	/**
	 * Gets value associated with key (in the form of splitted value)
	 * @param tokens tokens, generated by splitting logic
	 * @return Returns value associated with key/entry if found otherwise returns NULL
	 */
	public T get(String tokens[]) {
		NDLMapEntryNode<T> node = traverse(tokens);
		if(node != null && node.end) {
			// found and end
			return node.data;
		} else {		
			// not a valid case
			return null;
		}
	}
	
	/**
	 * Checks whether an entry exists in prefix-tree
	 * @param tokens tokens, generated by splitting logic
	 * @return returns true if found otherwise false
	 */
	public boolean containsKey(String tokens[]) {
		NDLMapEntryNode<T> node = traverse(tokens);
		if(node != null && node.end) {
			// found and end
			return true;
		} else {		
			// not a valid case
			return false;
		}
	}
	
	// traverse an entry and returns found node
	// returns node otherwise NULL
	NDLMapEntryNode<T> traverse(String tokens[]) { 
		NDLMapEntryNode<T> node = rootNode;
		boolean found = true;
		for(String token : tokens) {
			// traverse
			if(StringUtils.isNotBlank(token)) {
				// valid
				node = node.get(token);
				if(node == null) {
					found = false;
					break;
				}
			}
		}
		if(found) {
			return node;
		} else {
			return null;
		}
	}
	
	
	/**
	 * Iterates all keys present in prefix-tree
	 * @see #setKeyProcessor(NDLMapKeyProcessor)
	 */
	public void iterate() {
		// iterator
		Queue<NDLMapEntryNode<T>> nodes =  new LinkedList<NDLMapEntryNode<T>>();
		nodes.add(rootNode);
		while(!nodes.isEmpty()) {
			// iterate BFSwise
			NDLMapEntryNode<T> node = nodes.poll();
			if(node.end) {
				// end of entry, call processor
				if(keyProcessor != null) {
					keyProcessor.process(node.data);
				}
			}
			if(node.keys != null) {
				// if available
				nodes.addAll(node.keys.values()); // next nodes to traverse
			}
		}
	}
}